# Drive App

Db Digram [here](https://dbdiagram.io/d/DRIVEAPP_DB_STRUCTURE-6862cb32f413ba35089387ac)

# Coding Challenge: File and Media Management Platform with Upload

## Project Objective

Develop a full-stack web application for users to upload, store, view, and organize files and media (images, documents). This challenge aims to evaluate your ability to handle file uploads, cloud storage, and secure resource access.

## Context

Create a "mini-Dropbox" or "mini-Google Drive" where users can upload different types of files (images, PDFs, small videos), organize them into folders, and access them securely.

---

## Essential Requirements (MVP - Minimum Viable Product)

### 1. Backend (RESTful API)

* **Technologies:** Node.js (with Express.js or similar framework), TypeScript.
* **Authentication & Authorization:**
    * User registration (email, password).
    * User login (email, password).
    * Implement **JWT (JSON Web Tokens)** for authentication.
    * Ensure a user can only access, upload, or manage their own files.
* **User Management:** Basic CRUD (self-profile: view, update password/email).
* **File Upload:**
    * Endpoint for file uploads (support multiple files per request).
    * Utilize a library for upload handling (e.g., `multer`).
    * Store files in a **cloud storage service** (e.g., AWS S3, Google Cloud Storage, **Azure Blob Storage - preferred if you have Azure experience**).
    * Generate secure URLs (with expiration time) for file access.
    * Limit file size and type (e.g., images, PDFs, docs - minimum 2MB).
* **File/Metadata Management:**
    * Each file must have:
        * `id` (auto-generated)
        * `originalName` (string)
        * `serverName` (string, generated by service or server)
        * `mimeType` (string, e.g., "image/jpeg")
        * `size` (number, in bytes)
        * `accessUrl` (string, URL for download/view)
        * `userId` (ID of the user who uploaded the file)
        * `uploadDate` (Date, auto-generated)
        * `folderId` (ID of the folder where the file is located, optional)
    * **Endpoints:**
        * `GET /files`: List all files for the authenticated user.
        * `GET /files/:id`: Get details of a specific file.
        * `POST /files/upload`: Upload one or more files.
        * `DELETE /files/:id`: Delete a file (only by the owner, also remove from cloud storage).
        * `PUT /files/:id/rename`: Rename a file.
        * `PUT /files/:id/move`: Move a file to another folder.
* **Folder Management:**
    * Endpoints to create, rename, delete folders, and list files within a folder.
    * Folders should be hierarchical.
* **Data Persistence:**
    * **Required:** **MongoDB** (with Mongoose or native driver) to store file and folder metadata.
    * **Required:** **Redis** for caching temporary access URLs or for rate-limiting user uploads over a certain period.
* **Validation and Error Handling:** Validate input data and robust error handling.
* **Project Structure:** Logical and scalable organization.

### 2. Frontend (Web Application)

* **Technologies:** React/Next.js, TypeScript.
* **User Interface (UI):**
    * Login and Registration pages.
    * Main dashboard displaying the user's files and folders (can be in grid or list format).
    * File upload functionality (drag-and-drop or file selection button).
    * Upload progress indicator.
    * Options to rename, move, and delete files/folders.
    * Folder navigation.
    * Responsive design.
* **API Consumption:** Interact with the Backend API.
* **State Management:** Utilize Context API, Redux, Zustand, or a similar library.
* **Navigation:** Use Next.js routing system.
* **User Feedback:** Clear success, error, or loading messages.

---

## Additional Requirements (Differentiators)

These points are not mandatory for MVP completion but add significant value and demonstrate a higher level of expertise.

1.  **Testing:** Implement unit and/or integration tests for backend and/or frontend.
2.  **Deployment:** Deploy the full-stack application on a cloud platform (e.g., Azure App Services, Vercel/Netlify, MongoDB Atlas, Azure Blob Storage). Provide links.
3.  **Media Viewing:**
    * For images, display thumbnails.
    * For documents (PDF), attempt to embed a basic viewer or provide a direct link.
4.  **Search Functionality:** Allow the user to search for files by name.
5.  **Shopify Experience (ONLY IF APPLICABLE):**
    * *Alternative to File Management:* Create a Shopify App that allows the merchant to upload and manage **custom images for their products**, in addition to Shopify's standard images.
        * Utilize **Shopify Polaris** for the image upload and management interface in the Shopify admin.
        * Images should be stored in a cloud service (Azure Blob Storage preferred).
        * Allow these images to be selected and displayed on Shopify product pages, via **Liquid** or custom script injection.

---

## Project Submission

1.  **Git Repository:**
    * Create a public Git repository (GitHub, GitLab, Bitbucket).
    * Include this detailed `README.md` file.
    * Ensure the commit history is clean and reflects development progress.
2.  **Deadline:** The project must be submitted within **7 calendar days** from the receipt of this challenge.

---

## Evaluation Criteria

* **Functionality:** How well the essential requirements are met.
* **Code Quality:** Clarity, readability, modularity, code conventions, TypeScript usage.
* **Architecture and Design:** Project organization, separation of concerns, scalability.
* **Best Practices:** Error handling, data validation, security (JWT), state management, file storage.
* **Technology Usage:** Effective application of Node.js, React/Next.js, MongoDB, Redis/Azure Blob Storage.
* **Problem Solving:** The overall approach to solving the presented challenges.
* **Documentation:** Clarity and completeness of the `README.md` file.
* **Differentiators:** Added value from implemented additional requirements.

# Sumary

## What's inside?

This Turborepo includes the following packages/apps:

### Apps and Packages

    .
    ├── apps
    │   ├── api                       # NestJS app (https://nestjs.com).
    │   └── web                       # Next.js app (https://nextjs.org).
    └── packages
        ├── @repo/api                 # Shared `NestJS` resources.
        ├── @driveapp/eslint-config       # `eslint` configurations (includes `prettier`)
        ├── @driveapp/jest-config         # `jest` configurations
        ├── @driveapp/typescript-config   # `tsconfig.json`s used throughout the monorepo
        └── @repo/ui                  # Shareable stub React component library.

Each package and application are 100% [TypeScript](https://www.typescriptlang.org/) safe.

### Utilities

This `Turborepo` has some additional tools already set for you:

- [TypeScript](https://www.typescriptlang.org/) for static type-safety
- [ESLint](https://eslint.org/) for code linting
- [Prettier](https://prettier.io) for code formatting
- [Jest](https://prettier.io) & [Playwright](https://playwright.dev/) for testing

### Commands

This `Turborepo` already configured useful commands for all your apps and packages.

#### Build

```bash
# Will build all the app & packages with the supported `build` script.
yarn run build

# ℹ️ If you plan to only build apps individually,
# Please make sure you've built the packages first.
```

#### Develop

```bash
# Will run the development server for all the app & packages with the supported `dev` script.
yarn run dev
```

#### test

```bash
# Will launch a test suites for all the app & packages with the supported `test` script.
yarn run test

# You can launch e2e testes with `test:e2e`
yarn run test:e2e

# See `@driveapp/jest-config` to customize the behavior.
```

#### Lint

```bash
# Will lint all the app & packages with the supported `lint` script.
# See `@driveapp/eslint-config` to customize the behavior.
yarn run lint
```

#### Format

```bash
# Will format all the supported `.ts,.js,json,.tsx,.jsx` files.
# See `@driveapp/eslint-config/prettier-base.js` to customize the behavior.
yarn format
```

### Remote Caching

> [!TIP]
> Vercel Remote Cache is free for all plans. Get started today at [vercel.com](https://vercel.com/signup?/signup?utm_source=remote-cache-sdk&utm_campaign=free_remote_cache).

Turborepo can use a technique known as [Remote Caching](https://turbo.build/docs/core-concepts/remote-caching) to share cache artifacts across machines, enabling you to share build caches with your team and CI/CD pipelines.

By default, Turborepo will cache locally. To enable Remote Caching you will need an account with Vercel. If you don't have an account you can [create one](https://vercel.com/signup?utm_source=turborepo-examples), then enter the following commands:

```bash
npx turbo login
```

This will authenticate the Turborepo CLI with your [Vercel account](https://vercel.com/docs/concepts/personal-accounts/overview).

Next, you can link your Turborepo to your Remote Cache by running the following command from the root of your Turborepo:

```bash
npx turbo link
```

## Useful Links

Learn more about the power of Turborepo:

- [Tasks](https://turbo.build/docs/core-concepts/monorepos/running-tasks)
- [Caching](https://turbo.build/docs/core-concepts/caching)
- [Remote Caching](https://turbo.build/docs/core-concepts/remote-caching)
- [Filtering](https://turbo.build/docs/core-concepts/monorepos/filtering)
- [Configuration Options](https://turbo.build/docs/reference/configuration)
- [CLI Usage](https://turbo.build/docs/reference/command-line-reference)
